// ... (Código HTML e Style omitidos para brevidade)
// ... (Declarações de constantes e elementos DOM omitidas para brevidade)

<script>
    // URL BASE DA API - SUBSTITUA PELA SUA URL REAL DO BACKEND
    const API_BASE_URL = '/api/geplic'; 
    const API_ETAPAS = API_BASE_URL + '/etapas';
    const API_PROCESSO = API_BASE_URL + '/processo';
    
    // As chaves do LocalStorage para histórico de notificações ainda são usadas
    // pois a notificação é uma funcionalidade local do navegador.
    const LS_NOTIF_KEY = 'licitacao_notif_sent_v1'; 
    const DAYS_BEFORE_ALERT = 3;

    let currentPhase = 'Todos';
    let editingId = null;
    let draggedItem = null;
    
    // data e processInfo agora serão carregados pela API
    let data = []; 
    let processInfo = { number: '', object: '', startDate: '', endDate: '' };
    
    // ... (Declarações de elementos DOM e mapeamento de inputs omitidos)
    
    // --- FUNÇÕES DE API E PERSISTÊNCIA (NOVAS) ---
    
    // Função utilitária para chamar a API
    async function apiFetch(url, options = {}) {
        try {
            const response = await fetch(url, {
                headers: { 'Content-Type': 'application/json' },
                ...options
            });
            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`Erro de API: ${response.status} - ${errorBody}`);
            }
            return response.json();
        } catch (error) {
            console.error('Erro ao acessar a API:', error);
            alert('Erro de comunicação com o servidor. Verifique o console.');
            return null;
        }
    }

    // Adaptação de loadProcessInfo para carregar do servidor
    async function loadProcessInfo() {
        const result = await apiFetch(API_PROCESSO);
        if (result) {
             processInfo = {
                number: result.number || '',
                object: result.object || '',
                startDate: result.startDate || '',
                endDate: result.endDate || '',
            };
        }
        renderProcessInfo();
        renderTimeline();
    }

    // Adaptação de saveProcessInfo para salvar no servidor
    async function saveProcessInfo() {
        const newInfo = {
            number: configProcNumberInput.value.trim(),
            object: configProcObjectTextarea.value.trim(),
            startDate: configStartDateInput.value,
            endDate: configEndDateInput.value,
        };

        const result = await apiFetch(API_PROCESSO, {
            method: 'POST', // ou 'PUT' dependendo da sua API
            body: JSON.stringify(newInfo)
        });

        if (result) {
            // Se a API retornar o objeto salvo, atualize o local
            processInfo = newInfo;
            renderProcessInfo();
            renderTimeline();
            closeModalProcess();
        }
    }
    
    // Adaptação de load para carregar do servidor
    async function load() {
        const result = await apiFetch(API_ETAPAS);
        if (result && Array.isArray(result)) {
            data = result.map(item => ({...item, phase: item.phase || 'Interna'}));
        } else {
             data = [];
        }
        render(); // Chama o render após carregar os dados
    }

    // Adaptação de save (salva o array completo) para persistência no servidor
    // **NOTA:** Em um backend REST ideal, você faria POST/PUT por item, mas este
    // "save" é usado para reordenação/deletar tudo.
    async function save() {
        const result = await apiFetch(API_ETAPAS, {
            method: 'PUT', // Assume que o PUT atualiza toda a lista de etapas
            body: JSON.stringify(data)
        });
        if (result) {
             // Opcional: tratar a resposta do servidor se necessário
        }
        render(); // Garante a renderização após a tentativa de salvamento
    }
    
    // Adaptação de saveFromModal
    async function saveFromModal() {
        const obj = {
            procNumber: inputs.procNumber.value.trim(),
            stage: inputs.stage.value.trim(),
            responsible: inputs.responsible.value.trim(),
            emailResponsible: inputs.emailResponsible.value.trim(),
            deadline: inputs.deadline.value,
            phase: inputs.phaseSelect.value,
            status: inputs.statusSelect.value,
            note: inputs.note.value.trim()
        };
        if (!obj.stage || !obj.procNumber) {
            alert('Preencha pelo menos a Etapa e o Nº da Licitação.');
            return;
        }

        let result = null;
        if (editingId) {
            // EDIÇÃO (PUT)
            result = await apiFetch(`${API_ETAPAS}/${editingId}`, {
                method: 'PUT',
                body: JSON.stringify(obj)
            });
            if (result) {
                const idx = data.findIndex(x => x.id === editingId);
                if (idx >= 0) {
                    data[idx] = Object.assign({ id: editingId }, obj);
                }
            }
        } else {
            // NOVO ITEM (POST)
            result = await apiFetch(API_ETAPAS, {
                method: 'POST',
                body: JSON.stringify(obj)
            });
            if (result && result.id) { // Assume que o servidor retorna o objeto salvo com o novo ID
                data.push(Object.assign({ id: result.id }, obj));
            } else if(result) { // Fallback se o servidor não retorna um ID, mas a operação foi OK
                 data.push(Object.assign({ id: uid() }, obj));
            }
        }
        
        if(result) {
            render(); // Renderiza com os novos dados
            checkDeadlinesAndNotify();
            closeModal();
        }
    }

    // Adaptação de deleteItem
    window.deleteItem = async function(id) {
        if (!confirm('Apagar esta etapa?')) return;
        
        const result = await apiFetch(`${API_ETAPAS}/${id}`, {
            method: 'DELETE'
        });
        
        // Se a exclusão for bem-sucedida (status 204 No Content, ou 200 OK)
        if (result !== null) { 
            data = data.filter(x => x.id !== id);
            render();
        }
    }
    
    // Adaptação de deleteAllData
    async function deleteAllData() {
        if(data.length === 0) { alert("Não há dados para apagar."); return; }
        const confirmation = confirm("ATENÇÃO: Você realmente deseja apagar todos os dados do projeto? Esta ação é irreversível!");
        if (confirmation) {
            const result = await apiFetch(API_ETAPAS, {
                method: 'DELETE' // Assume que um DELETE no endpoint base apaga tudo
            });
            if(result !== null) {
                data = [];
                localStorage.removeItem(LS_NOTIF_KEY);
                render();
                alert("Todos os dados foram apagados com sucesso.");
            }
        }
    }

    // Adaptação de drop para salvar a reordenação
    async function drop(e) {
        e.preventDefault();
        this.style.borderTop = '';
        this.style.borderBottom = '';
        if (draggedItem === this || currentPhase === 'Todos') return;
        
        // ... (lógica de reordenação local do array 'data' é mantida) ...
        const draggedId = e.dataTransfer.getData('text/plain');
        const targetId = this.getAttribute('data-id');
        const phaseData = data.filter(item => item.phase === currentPhase);
        const otherData = data.filter(item => item.phase !== currentPhase);
        const draggedIndexInPhase = phaseData.findIndex(item => item.id === draggedId);
        const targetIndexInPhase = phaseData.findIndex(item => item.id === targetId);
        if (draggedIndexInPhase === -1 || targetIndexInPhase === -1) return;
        const item = phaseData.splice(draggedIndexInPhase, 1)[0];
        const rect = this.getBoundingClientRect();
        const midpoint = rect.y + rect.height / 2;
        let newTargetIndex = targetIndexInPhase;
        if (e.clientY > midpoint) { newTargetIndex++; }
        phaseData.splice(newTargetIndex, 0, item);
        data = otherData.concat(phaseData);
        
        // Salva a nova ordem no servidor
        await save(); 
    }
    
    // --- FUNÇÕES AUXILIARES, RENDERIZAÇÃO E INICIALIZAÇÃO (PEQUENAS ADAPTAÇÕES) ---

    // Função de inicialização adaptada para ser assíncrona
    async function initializeApp() {
        // Inicializa listeners (mantidos)
        btnRequestNotification.addEventListener('click', requestNotificationPermission);
        btnEditProcess.addEventListener('click', openModalProcess);
        btnCancelProcess.addEventListener('click', closeModalProcess);
        btnSaveProcess.addEventListener('click', saveProcessInfo); // Agora async
        btnAdd.addEventListener('click',()=>openModal());
        btnCancel.addEventListener('click',closeModal);
        btnSave.addEventListener('click',saveFromModal); // Agora async
        search.addEventListener('input',render);
        filterStatus.addEventListener('change',render);
        btnExport.addEventListener('click',exportXLSX);
        btnImport.addEventListener('click',()=>fileInput.click());
        fileInput.addEventListener('change',handleImport);
        btnDeleteAll.addEventListener('click', deleteAllData); // Agora async

        renderToday();
        await loadProcessInfo(); // Aguarda o carregamento das infos do processo
        await load(); // Aguarda o carregamento dos dados principais (render() é chamado dentro de load())
        checkDeadlinesAndNotify();
    }
    
    // A função switchPhase é mantida, mas 'render' agora é assíncrona
    window.switchPhase = function(phase) {
        currentPhase = phase;
        phaseButtons.forEach(btn => {
            if (btn.getAttribute('data-phase') === phase) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
        search.value = '';
        filterStatus.value = '';
        render();
    }
    
    // A função render é mantida, pois trabalha com o array 'data' que agora
    // é preenchido de forma assíncrona
    function render(){
        // ... (Corpo da função render inalterado) ...
        renderPhaseStatusBar();
        const q=search.value.toLowerCase().trim();
        const statusF=filterStatus.value;
        tbody.innerHTML='';
        const rows=data.filter(r=>{
            if (currentPhase !== 'Todos' && r.phase !== currentPhase) { return false; }
            if(statusF&&r.status!==statusF)return false;
            if(!q)return true;
            return [r.procNumber,r.stage,r.responsible,r.emailResponsible,(r.note||''), r.id].join(' ').toLowerCase().includes(q);
        });
        if(rows.length===0){empty.style.display='block';}else{empty.style.display='none';}
        rows.forEach((r)=>{
             // ... (Geração do HTML da linha da tabela inalterada) ...
            const tr=document.createElement('tr');
            const days=calcDays(r.deadline);
            const isDraggable = currentPhase !== 'Todos' && !q && !statusF;
            if (isDraggable) {
                tr.setAttribute('draggable', 'true');
                tr.setAttribute('data-id', r.id);
                tr.addEventListener('dragstart', dragStart);
                tr.addEventListener('dragover', dragOver);
                tr.addEventListener('drop', drop); // drop é assíncrona
                tr.addEventListener('dragend', dragEnd);
            } else {
                tr.setAttribute('draggable', 'false');
                tr.style.cursor = 'default';
            }
             tr.innerHTML=`
             <td data-label="#">${data.findIndex(item => item.id === r.id) + 1}</td>
             <td data-label="Nº Licitação">${escapeHtml(r.procNumber||'')}</td>
             <td data-label="Etapa">${escapeHtml(r.stage||'')} <br><span class="small" style="font-weight: bold;">(${r.phase})</span></td>
             <td data-label="Responsável">${escapeHtml(r.responsible||'')} <br><span class="small">${escapeHtml(r.emailResponsible||'-')}</span></td>
             <td data-label="Prazo">${r.deadline||''}</td>
             <td data-label="Status"><span class="chip ${statusClass(r.status)}">${r.status||'Pendente'}</span></td>
             <td data-label="Observação">${escapeHtml(r.note||'')}</td>
             <td data-label="Dias">${daysDisplay(days)}</td>
             <td data-label="Ações">
               <button style="background: var(--blue-main); padding: 6px 10px; font-size: 13px;" onclick="editItem('${r.id}')">Editar</button>
               <button style="background: var(--danger); padding: 6px 10px; font-size: 13px;" onclick="deleteItem('${r.id}')">Apagar</button>
             </td>`;
            tbody.appendChild(tr);
        });
    }

    // Função de inicialização no carregamento da página (substitui o `onload` do body)
    document.addEventListener('DOMContentLoaded', initializeApp);

    // ... (As outras funções auxiliares: renderPhaseStatusBar, renderTimeline, renderProcessInfo, 
    // openModalProcess, closeModalProcess, openModal, closeModal, 
    // editItem, dragStart, dragOver, dragEnd, uid, statusClass, calcDays, 
    // daysDisplay, exportXLSX, handleImport, escapeHtml, requestNotificationPermission, 
    // loadNotificationHistory, saveNotificationHistory, checkDeadlinesAndNotify são mantidas ou adaptadas de forma mínima) ...

</script>
</body>
</html>
